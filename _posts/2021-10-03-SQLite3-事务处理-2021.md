---
layout:     post
title:      "SQLite3 事务处理, 2021"
subtitle:   "欢迎使用"
date:       2021-10-03 14:25:20
author:     "Ruer"
header-img: "img/bg/hello_world.jpg"
catalog: true
tags:
    - SQLite3
---

事务处理是 DBMS 中最关键的技术，对 SQLite 也一样，它涉及到并发控制，以及故障恢复。本文通过一个具体的例子来分析 SQLite 原子提交的实现。

```SQL
CREATE TABLE episodes( id integer primary key,name text, cid int) ；
```

插入一条记录：insert into episodes(name,cid) values("cat",1) 。它经过编译器处理后生成的虚拟机代码如下：

```SQL
sqlite> explain insert into episodes(name,cid) values("cat",1);
0|Trace|0|0|0|explain insert into episodes(name,cid) values("cat",1);|00|
1|Goto|0|12|0||00|
2|SetNumColumns|0|3|0||00|
3|OpenWrite|0|2|0||00|
4|NewRowid|0|2|0||00|
5|Null|0|3|0||00|
6|String8|0|4|0|cat|00|
7|Integer|1|5|0||00|
8|MakeRecord|3|3|6|dad|00|
9|Insert|0|6|2|episodes|0b|
10|Close|0|0|0||00|
11|Halt|0|0|0||00|
12|Transaction|0|1|0||00|
13|VerifyCookie|0|1|0||00|
14|Transaction|1|1|0||00|
15|VerifyCookie|1|0|0||00|
16|TableLock|0|2|1|episodes|00|
17|Goto|0|2|0||00|
```

## 初始状态

当一个数据库连接第一次打开时，状态如图所示。图中最右边（“Disk”标注）表示保存在存储设备中的内容。每个方框代表一个扇区。蓝色的块表示这个扇区保存了原始数据。图中中间区域是操作系统的磁盘缓冲区。开始的时候，这些缓存是还没有被使用，因此这些方框是空白的。图中左边区域显示 SQLite 用户进程的内存。因为这个数据库连接刚刚打开，所以还没有任何数据记录被读入，所以这些内存也是空的。

![1](/img/SQLite3/初始状态.gif)

## 获取读锁

在 SQLite 写数据库之前，它必须先从数据库中读取相关信息。比如，在插入新的数据时，SQLite 会先从 sqlite_master 表中读取数据库模式(相当于数据字典)，以便编译器对 INSERT 语句进行分析，确定数据插入的位置。

在进行读操作之前，必须先获取数据库的共享锁(shared lock)，共享锁允许两个或更多的连接在同一时刻读取数据库。但是共享锁不允许其它连接对数据库进行写操作。

shared lock 存在于操作系统磁盘缓存，而不是磁盘本身。文件锁的本质只是操作系统的内核数据结构，当操作系统崩溃或掉电时，这些内核数据也会随之消失。

![2](/img/SQLite3/获取读锁.gif)

## 读取数据

一旦得到 shared lock，就可以进行读操作。如图所示，数据先由 OS 从磁盘读取到 OS 缓存，然后再由 OS 移到用户进程空间。一般来说，数据库文件分为很多页，而一次读操作只读取一小部分页面。如图，从8个页面读取3个页面。

![3](/img/SQLite3/读取数据.gif)

## 获取Reserved Lock

在对数据进行修改操作之前，先要获取数据库文件的 Reserved Lock，Reserved Lock 和 shared lock 的相似之处在于，它们都允许其它进程对数据库文件进行读操作。Reserved Lock 和 Shared Lock 可以共存，但是只能是一个Reserved Lock 和多个 Shared Lock —— 多个Reserved Lock 不能共存。所以，在同一时刻，只能进行一个写操作。

Reserved Lock 意味着当前进程(连接)想修改数据库文件，但是还没开始修改操作，所以其它的进程可以读数据库，但不能写数据库。

![4](/img/SQLite3/获取Reserved Lock.gif)

## 创建恢复日志

在对数据库进行写操作之前，SQLite 先要创建一个单独的日志文件，然后把要修改的页面的原始数据写入日志。回滚日志包含一个日志头(图中的绿色)——记录数据库文件的原始大小。所以即使数据库文件大小改变了，我们仍知道数据库的原始大小。

在对数据库进行写操作之前，SQLite 先要创建一个单独的日志文件，然后把要修改的页面的原始数据写入日志。回滚日志包含一个日志头(图中的绿色)——记录数据库文件的原始大小。所以即使数据库文件大小改变了，我们仍知道数据库的原始大小。

![5](/img/SQLite3/创建恢复日志.gif)

其实现过程如下图所示：

![6](/img/SQLite3/创建恢复日志2.gif)

## 修改位于用户进程空间的页面

页面的原始数据写入日志之后，就可以修改页面了——位于用户进程空间。每个数据库连接都有自己私有的空间，所以页面的变化只对该连接可见，而对其它连接的数据仍然是磁盘缓存中的数据。从这里可以明白一件事：一个进程在修改页面数据的同时，其它进程可以继续进行读操作。图中的红色表示修改的页面。

![7](/img/SQLite3/修改位于用户进程空间的页面.gif)

## 日志文件刷入磁盘

接下来把日志文件的内容刷入磁盘，这对于数据库从意外中恢复来说是至关重要的一步。而且这通常也是一个耗时的操作，因为磁盘 I/O 速度很慢。

这个步骤不只把日志文件刷入磁盘那么简单，它的实现实际上分成两步：首先把日志文件的内容刷入磁盘（即页面数据）；然后把日志文件中页面的数目写入日志文件头，再把 header 刷入磁盘。

![8](/img/SQLite3/日志文件刷入磁盘.gif)

## 获取排斥锁

在对数据库文件进行修改之前(注：这里不是内存中的页面),我们必须得到数据库文件的排斥锁(Exclusive Lock)。得到排斥锁的过程可分为两步：首先得到 Pending lock；然后 Pending lock 升级到 exclusive lock。

Pending lock 允许其它已经存在的 Shared lock 继续读数据库文件，但是不允许产生新的 shared lock，这样做目的是为了防止写操作发生饿死情况。一旦所有的 shared lock 完成操作，则 pending lock 升级到 exclusive lock。

![9](/img/SQLite3/获取排斥锁.gif)

## 修改的页面写入文件

一旦得到 exclusive lock，其它的进程就不能进行读操作，此时就可以把修改的页面写回数据库文件，但是通常 OS 都把结果暂时保存到磁盘缓存中，直到某个时刻才会真正把结果写入磁盘。

![10](/img/SQLite3/修改的页面写入文件.gif)

## 修改结果刷入存储设备

为了保证修改结果真正写入磁盘，这一步必不要少。对于数据库存的完整性，这一步也是关键的一步。由于要进行实际的 I/O 操作，所以和第7步一样，将花费较多的时间。

![11](/img/SQLite3/修改结果刷入存储设备.gif)

下图可以进一步解释该过程：

![12](/img/SQLite3/修改结果刷入存储设备2.gif)

## 删除日志文件

一旦更改写入设备，日志文件将会被删除，这是事务真正提交的时刻。如果在这之前系统发生崩溃，就会进行恢复处理，使得数据库和没发生改变一样；如果在这之后系统发生崩溃，表明所有的更改都已经写入磁盘。SQLite 就是根据日志存在情况决定是否对数据库进行恢复处理。

删除文件本质上不是一个原子操作，但是从用户进程的角度来看是一个原子操作，所以一个事务看起来是一个原子操作。

在许多系统中，删除文件也是一个高代价的操作。作为优化，SQLite 可以配置成把日志文件的长度截为0或者把日志文件头清零。

![13](/img/SQLite3/删除日志文件.gif)

## 释放锁

作为原子提交的最后一步，释放排斥锁使得其它进程可以开始访问数据库了。

下图中，我们指明了当锁被释放的时候用户空间所拥有的信息已经被清空了.对于老版本的 SQLite 你可这么认为。但最新的 SQLite 会保存些用户空间的缓存不会被清空—万一下一个事务开始的时候，这些数据刚好可以用上呢。重新利用这些内存要比再次从操作系统磁盘缓存或者硬盘中读取要来得轻松与快捷得多，何乐而不为呢？在再次使用这些数据之前，我们必须先取得一个共享锁，同时我们还不得不去检查一下，保证还没有其他进程在我们拥有共享锁之前对数据库文件进行了修改。数据库文件的第一页中有一个计数器，数据库文件每做一次修改，这个计数器就会增长一下。我们可以通过检查这个计数器就可得知是否有其他进程修改过数据库文件。如果数据库文件已经被修改过了，那么用户内存空间的缓存就不得不清空，并重新读入。大多数情况下，这种情况不大会发生，因此用户空间的内存缓存将是有效的，这对于性能提高来说作用是显著的。

![14](/img/SQLite3/释放锁.gif)

下图可进一步描述该过程：

![15](/img/SQLite3/释放锁2.gif)