---
layout:     post
title:      "makefile 书写规则, 2021"
subtitle:   "规则"
date:       2021-05-11 13:09:00
author:     "Ruer"
header-img: "img/bg/hello_world.jpg"
catalog: true
tags:
    - makefile
---

## 规则的语法

```
targets : prerequisites
  command
  ...
```

或是这样：

```
targets : prerequisites ; command
  command
  ...
```

`targets` 是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。
`command` 是命令行，如果其不与“target:prerequisites”在一行，那么，必须以 Tab 键开头，如果和 prerequisites 在一行，那么可以用分号做为分隔。（见上）
`prerequisites` 也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。

如果命令太长，你可以使用反斜杠（\ ）作为换行符。 make 对一行上有多少个字符没有限制。规则告诉 make 两件事，文件的依赖关系和如何生成目标文件。一般来说， make 会以 UNIX 的标准 Shell，也就是 /bin/sh 来执行命令。

## 在规则中使用通配符

#### 基础用法

如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。 make 支持三个通配符： `*` 、 `?` 和 `~` 。这是和 Unix 的 B-Shell 是相同的。

波浪号（~ ）字符在文件名中也有比较特殊的用途。如果是 ~/test ，这就表示当前用户的 $HOME 目录下的 test 目录。而 ~hchen/test 则表示用户 hchen 的宿主目录下的 test 目录。（这些都是 Unix 下的小知识了， make 也支持）而在 Windows 或是 MS-DOS 下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。

通配符代替了你一系列的文件，如 *.c 表示所有后缀为 c 的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如： * ，那么可以用转义字符 \ ，如 \* 来表示真实的 * 字符，而不是任意长度的字符串。

先来看几个例子：

```
clean:
  rm -f *.o
```

其结果你试一下就知道的。上面这个例子我不不多说了，这是操作系统 Shell 所支持的通配符。

```
print: *.c
  lpr -p $?
  touch print
```

上面这个例子说明了通配符也可以在我们的规则中，目标 print 依赖于所有的 .c 文件。其中的 $? 是一个自动化变量。

#### 一个变量使用通配符的例子：

```
objects = *.o
```

上面这个例子，表示了通配符同样可以用在变量中。并不是说 *.o 会展开，objects 的值就是 *.o 。 Makefile 中的变量其实就是 C/C++ 中的宏。如果你要让通配符在变量中展开，也就是让 objects 的值是所有 .o 的文件名的集合，那么，你可以这样：

```
objects := $(wildcard *.o)
```

#### 另一个变量使用通配符的例子：

1. 列出一确定文件夹中的所有 .c 文件。

```
objects := $(wildcard *.c)
```

2. 列出 (1) 中所有文件对应的 .o 文件，在（3）中我们可以看到它是由 make 自动编译出的:

```
$(patsubst %.c,%.o,$(wildcard *.c))
```

3. 由 (1)(2) 两步，可写出编译并链接所有 .c 和 .o 文件

```
objects := $(patsubst %.c,%.o,$(wildcard *.c))
foo : $(objects)
  cc -o foo $(objects)
```

这种用法由关键字“wildcard”，“patsubst”指出。