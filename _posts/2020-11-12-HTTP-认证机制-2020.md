---
layout:     post
title:      "HTTP 认证机制, 2020"
subtitle:   "介绍"
date:       2020-11-12 08:54:00
author:     "Ruer"
header-img: "img/bg/hello_world.jpg"
catalog: true
tags:
    - HTTP
---

## 认证

所谓认证，就是用户给出身份证明，然后服务器加以验证。HTTP提供了质询/响应认证框架用以简化认证过程：

1. Web应用程序收到HTTP请求。
2. Web应用程序以一个“认证质询”作为响应。
3. 用户提供身份证明。
4. 服务器验证身份证明。

HTTP定义了两个官方的认证协议：`基本认证`和`摘要认证`。（开发人员也可以设计自己的认证协议）

不同的认证协议其对应的首部及实现机制会有所差别。 但认证一般包括以下步骤:

![1](/img/HTTP/认证步骤.png)

为了让服务器上不同的资源有不同的认证权限，HTTP设计者提出了`安全域`的概念，其实现机制是：在WWW-Authenticate质询中包含了一个realm指令。 Web服务器会将受保护的文档组织成一个安全域，每个安全域有自己的授权用户集。

## 基本认证

基本认证是目前最流行的HTTP认证协议，几乎每个主要的HTTP客户端和服务器都实现了基本认证机制。

#### 流程

在基本认证中，Web服务器拒绝事务，质询客户端，请客户端提供用户名和密码。服务器返回401状态码来初始化质询，并用WWW-authenticate响应首部指定要访问的安全域。 浏览器收到质询时，会打开客户端，请求用户输入这个域的用户名和密码。然后浏览器为用户名和密码添加扰码，再用Authorization请求首部回复给服务器。

`Base-64编码`：在基本认证中，用户名和密码被打包在一起，并用Base-64编码方式对其进行编码。

`代理认证`：中间的代理服务器也可以实现认证功能。 代理认证步骤域Web服务器身份认证步骤相同，但首部和状态码有一些区别。

#### 缺陷

基本认证很容易导致用户名和密码泄露。

在基本认证中，用户名和密码在网络中传输，尽管进行了（如Base-64编码方式）加密，这些密文也很容易被破解。就算没有被破解，恶意用户也可以直接使用密文的密码通过服务器的认证。

另外，一些恶意的用户也可以伪装成服务器骗取用户的用户名和密码。

## 摘要认证

尽管基本认证便捷灵活，但存在极大的安全性问题。针对认证的安全性，摘要认证做了一些改进，很大程度上避免了安全性问题。

以下是摘要认证做的一些改进错误：

1. 永远不会以明文方式在网络上发送密码。（Base-64加密几乎相当于明文）
2. 可以防止恶意用户捕获并重放认证的握手过程。
3. 可以有选择低防止对报文内容的篡改。
4. 防范一些其他的常见的攻击方式。

<b>摘要认证的握手过程</b>

1. 第一次客户端请求的时候，服务器产生一个随机数nonce，服务器将这个随机数放在WWW-Authenticate响应头，与服务器支持的认证算法列表，认证的域realm一起发送给客户端，如下例子：

    ```
    HTTP /1.1 401 Unauthorized

    WWW-Authenticate:Digest

    realm= ”test realm”

    qop=auth,auth-int”

    nonce=”66C4EF58DA7CB956BD04233FBB64E0A4”
    ```

2. 客户端发现是401响应，表示需要进行认证，则弹出让用户输入用户名和密码的认证窗口，客户端选择一个算法，计算出密码和其他数据的摘要，将摘要放到Authorization的请求头中发送给服务器，如果客户端要对服务器也进行认证，这个时候，可以发送客户端随机数cnonce。如下例子：

    ```
    GET/cgi-bin/checkout?a=b HTTP/1.1

    Authorization: Digest

    username=”tenfyguo”

            realm=”test realm”

            nonce=” 66C4EF58DA7CB956BD04233FBB64E0A4” //服务器端的随机数一起带回

            uri=”/cgi-bin/checkout?a=b” //必须跟请求行一致

            qop=”auth” //保护质量参数

            nc=0000001

            cnonce=”xxxxx234132543strwerr65sgdrftdfytryts” //客户端随机数，用于对称校验

            response=” ABC4EF58DA7CB956BD04345FBB64E0A4”//最终摘要
    ```

3. 服务接受摘要，选择算法以及掌握的数据，重新计算新的摘要跟客户端传输的摘要进行比较，验证是否匹配，若客户端反过来用客户端随机数对服务器进行质询，就会创建客户端摘要，服务可以预先将下一个随机数计算出来，提前传递给客户端，通过Authentication-Info发送下一个随机数。如下例子：

    ```
    HTTP/1.1 200 OK

    Authorization-Info:nextnonce=” 88C4EF58DA7CB956BD04233FBB64E0A4”

    qop=”auth”

    rspauth=”23543534DfasetwerwgDTerGDTERERRE”

    cnonce=” xxxxx234132543strwerr65sgdrftdfytryts”
    ```