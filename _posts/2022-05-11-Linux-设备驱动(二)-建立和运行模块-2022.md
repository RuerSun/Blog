---
layout:     post
title:      "Linux 设备驱动(二) 建立和运行模块, 2022"
subtitle:   "欢迎使用"
date:       2022-05-11 12:51:20
author:     "Ruer"
header-img: "img/bg/hello_world.jpg"
catalog: true
tags:
    - Linux
---

# Hello World 模块

```C
#include <linux/init.h>
#include <linux/module.h>
MODULE_LICENSE("Dual BSD/GPL");

static int hello_init(void)
{
    printk(KERN_ALERT "Hello, world\n");
    return 0;
}

static void hello_exit(void)
{
    printk(KERN_ALERT "Goodbye, cruel world\n");
}

module_init(hello_init);
module_exit(hello_exit);
```

这个模块定义了两个函数, 一个在模块加载到内核时被调用( hello_init )以及一个在模块被去除时被调用( hello_exit ). `moudle_init` 和 `module_exit` 这几行使用了特别的内核宏来指出这两个函数的角色. 另一个特别的宏 (MODULE_LICENSE) 是用来告知内核, 该模块带有一个自由的许可证. 没有这样的说明, 在模块加载时内核会警告.

`printk` 函数在 Linux 内核中定义并且对模块可用. 它与标准 C 库函数 printf 的行为相似. 内核需要它自己的打印函数, 因为它靠自己运行, 没有 C 库的帮助. 模块能够调用 `printk` 是因为, 在 `insmod` 加载了它之后, 模块被连接到内核并且可存取内核的公用符号(函数和变量). 字串 `KERN_ALERT` 是消息的优先级. 在此模块中指定了一个高优先级, 因为使用缺省优先级的消息可能不会在任何有用的地方显示, 这依赖于运行的内核版本, `klogd` 守护进程的版本, 以及配置.

你可以用 `insmod` 和 `rmmod` 工具来测试这个模块. 注意只有超级用户可以加载和卸载模块.

![1](/img/Linux/驱动编程/模块加载卸载内部逻辑.png)

```SHELL
root# insmod ./hello.ko
Hello, world
root# rmmod hello
Goodbye cruel world
```

# 内核模块相比于应用程序

<b>用户空间和内核空间</b>

模块在内核空间运行, 而应用程序在用户空间运行. 这个概念是操作系统理论的基础.

Linux 系统设计成使用了两个级别. 内核在最高级运行( 也称之为超级模式 ), 这里任何事情都允许, 而应用程序在最低级运行(所谓的用户模式), 这里处理器控制了对硬件的直接存取以及对内存的非法存取.

一个应用程序发出一个系统调用或者被硬件中断挂起时, 从用户空间转换执行到内核空间. 执行系统调用的内核代码在进程的上下文中工作 -- 它代表调用进程并且可以存取该进程的地址空间. 换句话说, 处理中断的代码对进程来说是异步的, 不和任何特别的进程有关.

<b>内核并发</b>

内核编程与传统应用程序编程方式很大不同的是并发问题. 大部分应用程序( 多线程的应用程序例外 )是顺序运行的, 
内核代码没有运行在这样的简单环境中, 即便最简单的内核模块必须在这样的概念下编写.内核编程中有几个并发的来源. 在同一时间, 不止一个进程能够试图使用你的驱动, 可能在你的驱动试图做其他事情的同一时间被调用. 

所以 Linux 内核代码包括驱动代码, 必须是可重入的. 它必须能够同时在多个上下文中运行. 数据结构必须小心设计以保持多个执行线程分开, 并且代码必须小心存取共享数据, 避免数据的破坏. 

<b>当前进程</b>

尽管内核模块不像应用程序一样顺序执行, 内核做的大部分动作是代表一个特定进程的. 内核代码可以引用当前进程, 通过存取全局项 `current`, 它在 `<asm/current.h>` 中定义, 它产生一个指针指向结构 `task_struct`, 在 `<linux/sched.h>` 定义. `current` 指针指向当前在运行的进程. 在一个系统调用执行期间, 例如 `open` 或者 `read`, 当前进程是发出调用的进程. 一个设备驱动可以只包含 `<linux/sched.h>` 并且引用当前进程. 例如下面的语句打印了当前进程的进程 ID 和命令名称, 通过存取结构 task_struct 中的某些字段.

```C
printk(KERN_INFO "The process is \"%s\" (pid %i)\n", current->comm, current->pid);
```

存于 current->comm 的命令名称是由当前进程执行的程序文件的基本名称.

<b>几个细节</b>

应用程序存在于虚拟内存中, 有一个非常大的堆栈区, 用来保存函数调用历史以及所有的由当前活跃的函数创建的临时变量. 内核相反, 有一个非常小的堆栈. 它可能小到一个 4096 字节的页. 你的函数必须与这个内核空间调用链共享这个堆栈. 因此应该避免声明一个巨大的临时变量, 或者在调用时间内动态分配.

查看内核 API 时, 经常会遇到以双下划线(__)开始的函数名. 这样标志的函数名通常是一个低层的接口组件, 应当小心使用. 本质上讲, 双下划线告诉程序员:" 如果你调用这个函数, 确信你知道你在做什么."

内核代码不能做浮点算术, 使能浮点将要求内核在每次进出内核空间的时候保存和恢复浮点处理器的状态, 造成额外的负担.