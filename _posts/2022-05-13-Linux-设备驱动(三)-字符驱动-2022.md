---
layout:     post
title:      "Linux 设备驱动(三) 字符驱动, 2022"
subtitle:   "欢迎使用"
date:       2022-05-13 12:31:20
author:     "Ruer"
header-img: "img/bg/hello_world.jpg"
catalog: true
tags:
    - Linux
---

## scull 的设计

贯串本章, 展示从一个真实设备驱动提取的代码片段: `scull`( Simple Character Utility for Loading Localities). scull 是一个字符驱动, 操作一块内存区域好像它是一个设备, 不依赖硬件. scull 只演示内核和字符驱动的接口和允许用户运行一些测试之外, 不做任何有用的事情. scull 源码实现下面的设备.  

* scull0 到 scull3

> 4 个设备, 每个由一个全局永久的内存区组成. 全局意味着如果设备被多次打开, 设备中含有的数据由所有打开它的文件描述符共享. 永久意味着如果设备关闭又重新打开, 数据不会丢失. 可以用惯常的命令来存取和测试, 例如 cp 和 cat, 以及 I/O 重定向.

* scullpipe0 到 scullpipe3

> 4 个 FIFO (先入先出) 设备, 行为象管道. 一个进程读的内容来自另一个进程所写的. 如果多个进程读同一个设备, 它们竞争数据. scullpipe 的内部将展示阻塞读写和非阻塞读写如何实现, 而不必采取中断. 尽管真实的驱动使用硬件中断来同步它们的设备, 阻塞和非阻塞操作的主题是重要的并且与中断处理是分开的.  

* scullsingle
* scullpriv
* sculluid
* scullwuid

> 这些设备与 scull0 相似, 但是在什么时候允许打开上有一些限制. 第一个( snullsingle) 只允许一次一个进程使用驱动, 而 scullpriv 对每个虚拟终端(或者 X 终端会话)是私有的, 因为每个控制台/终端上的进程有不同的内存区.
sculluid 和 scullwuid 可以多次打开, 但是一次只能是一个用户. 前者返回一个"设备忙"错误, 如果另一个用户锁着设备, 而后者实现阻塞打开.  

## 主次编号

字符设备通过文件系统中的名子来存取. 那些名子称为文件系统的特殊文件, 或者设备文件, 或者文件系统的简单结点, 位于 /dev 目录. 字符驱动的特殊文件由使用ls -l 的输出的第一列的"c"标识. 块设备也出现在 /dev 中, 但是它们由"b"标识.  

```Shell
crw-rw-rw- 1 root root 1, 3 Apr 11 2002 null
crw------- 1 root root 10, 1 Apr 11 2002 psaux
crw------- 1 root root 4, 1 Oct 28 03:04 tty1
crw-rw-rw- 1 root tty 4, 64 Apr 11 2002 ttys0
crw-rw---- 1 root uucp 4, 65 Apr 11 2002 ttyS1
crw--w---- 1 vcsa tty 7, 1 Apr 11 2002 vcs1
crw--w---- 1 vcsa tty 7,129 Apr 11 2002 vcsa1
crw-rw-rw- 1 root root 1, 5 Apr 11 2002 zero
```

发出 ls -l 命令, 会看到在设备文件项中有 2 个数(由一个逗号分隔)在最后修改日期前面, 这些数字是给特殊设备的主次设备编号. 它们的主编号是 1, 4, 7, 和 10, 而次编号是 1, 3, 5, 64, 65, 和 129.  

传统上, 主编号标识设备相连的驱动. 例如, /dev/null 和 /dev/zero 都由驱动 1 来管理, 而虚拟控制台和串口终端都由驱动 4 管理. 同样, vcs1 和 vcsa1 设备都由驱动 7 管理. 现代 Linux 内核允许多个驱动共享主编号, 但是大部分设备仍然按照一个主编号一个驱动的原则来组织.

次编号被内核用来决定引用哪个设备. 依据你的驱动是如何编写的, 可以从内核得到一个你的设备的直接指针, 或者可以自己使用次编号作为本地设备数组的索引. 不论哪个方法, 内核自己几乎不知道次编号的任何事情, 除了它们指向你的驱动实现的设备.  

<b>设备编号的内部表示</b>

在内核中, `dev_t` 类型(在 `<linux/types.h>`中定义)用来持有设备编号. 利用在 `<linux/kdev_t.h>` 中的一套宏定义, 获得一个 dev_t 的主或者次编号.  

```C
MAJOR(dev_t dev);
MINOR(dev_t dev);
```

相反, 如果有主次编号, 需要将其转换为一个 dev_t, 使用:

```C
MKDEV(int major, int minor);
```

<b>分配和释放设备编号</b>

在建立一个字符驱动时需要做的第一件事是获取一个或多个设备编号来使用. 函数是 `register_chrdev_region`, 在 `<linux/fs.h>` 中声明:

```C
int register_chrdev_region(dev_t first, unsigned int count, char *name);
```

这里, `first` 是要分配的起始设备编号, 次编号部分常常是 0. `count` 是请求的连续设备编号的总数. `name` 是应当连接到这个编号范围的设备的名子. 它会出现在 /proc/devices 和 sysfs 中. 如果分配成功进行, register_chrdev_region 的返回值是 0. 出错的情况下, 返回一个负的错误码, 不能存取请求的区域.

也可以让内核动态分配一个主编号.  

```C
int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name);
```

使用这个函数, `dev` 是在函数成功完成时持有的分配范围的第一个数. `fisetminor` 是请求的第一个要用的次编号, 常常是 0. `count` 和 `name` 参数如同给 request_chrdev_region 的一样.

在不再使用它们时应释放它, 设备编号的释放使用:

```C
void unregister_chrdev_region(dev_t first, unsigned int count);
```

对于新驱动, 强烈建议使用动态分配来获取主设备编号, 而不是随机选取一个当前空闲的编号. 换句话说, 驱动应当使用 alloc_chrdev_region, 不是 register_chrdev_region.  

## 一些重要数据结构

首先需要了解基础的驱动操作, 包括 3 个重要的内核数据结构, 称为 file_operations、file 和 inode. 

<b>文件操作</b>

`file_operation` 结构定义在 `<linux/fs.h>`, 是一个函数指针的集合. 每个打开文件与它自身的函数集合相关连( 通过包含一个称为 `f_op` 的成员 ). 这些操作大部分负责实现系统调用, 因此命名为 `open`、`read` 等等. 可以认为文件是一个"对象"并且其上的函数操作称为它的"方法". 结构中的每个成员必须指向驱动中的函数, 这些函数实现一个特别的操作, 或者对于不支持的操作留置为 `NULL`. 当指定为 NULL 指针时内核的确切的行为是每个函数不同的.

通读 `file_operations` 方法的列表时, 会注意到不少参数包含字串 `__user`. 这种注解是一种文档形式, 一个指针是一个不能被直接解引用的用户空间地址. 对于正常的编译, __user 没有效果, 但是它可被外部检查软件使用来找出对用户空间地址的错误使用.

* struct module *owner

> 第一个 file_operations 成员不是一个操作, 它是一个指向拥有这个结构的模块的指针. 这个成员用来在它的操作还在被使用时阻止模块被卸载. 几乎所有时间中, 它被简单初始化为 `THIS_MODULE`, 一个在 `<linux/module.h>` 中定义的宏.

* loff_t (*llseek) (struct file *, loff_t, int);

> llseek 方法用作改变文件中的当前读/写位置, 并且新位置作为(正的)返回值. loff_t 参数是一个"long offset", 并且就算在 32 位平台上也至少 64 位宽. 错误由一个负返回值指示. 如果这个函数指针是 NULL, seek 调用会以潜在地无法预知的方式修改 file 结构中的位置计数器.

* ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);

> 用来从设备中获取数据. 在这个位置的一个空指针导致 read 系统调用以 EINVAL("Invalid argument") 失败. 一个非负返回值代表了成功读取的字节数( 返回值是一个 "signed size" 类型, 常常是目标平台本地的整数类型 ).

* ssize_t (*aio_read)(struct kiocb *, char __user *, size_t, loff_t);

> 初始化一个异步读. 如果这个方法是 NULL, 所有的操作会由 read 代替进行(同步地).

* ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);

> 发送数据给设备. 如果 NULL, -EINVAL 返回给调用 write 系统调用的程序. 如果非负, 返回值代表成功写的字节数.

* ssize_t (*aio_write)(struct kiocb *, const char __user *, size_t, loff_t *);

> 初始化设备上的一个异步写.

* int (*readdir) (struct file *, void *, filldir_t);

> 对于设备文件这个成员应当为 NULL; 它用来读取目录, 并且仅对文件系统有用.

* unsigned int (*poll) (struct file *, struct poll_table_struct *);

> poll 方法是 3 个系统调用的后端: `poll`、`epoll` 和 `select`, 都用作查询对一个或多个文件描述符的读或写是否会阻塞. poll 方法应当返回一个位掩码指示是否非阻塞的读或写是可能的, 并且提供给内核信息用来使调用进程睡眠直到 I/O 变为可操作. 如果一个驱动的 poll 方法为 NULL, 设备假定为不阻塞地可读可写.

* int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);

> ioctl 系统调用提供了发出设备特定命令的方法(例如格式化软盘的一个磁道, 这不是读也不是写). 另外, 几个 ioctl 命令被内核识别而不必引用 fops 表. 如果设备不提供 ioctl 方法, 对于任何未事先定义的请求(-ENOTTY, "设备无这样的 ioctl"), 系统调用返回一个错误.

* int (*mmap) (struct file *, struct vm_area_struct *);

> mmap 用来请求将设备内存映射到进程的地址空间. 如果这个方法是 NULL, mmap 系统调用返回 -ENODEV.

* int (*open) (struct inode *, struct file *);

> 尽管这常常是对设备文件进行的第一个操作, 不要求驱动声明一个对应的方法. 如果这个项是 NULL, 设备打开一直成功, 但是驱动不会得到通知.

* int (*flush) (struct file *);

> flush 操作在进程关闭它的设备文件描述符的拷贝时调用, 它应当执行(并且等待)设备的任何未完成的操作. 这个必须不要和用户查询请求的 fsync 操作混淆了. 当前, flush 在很少驱动中使用; SCSI 磁带驱动使用它, 例如为确保所有写的数据在设备关闭前写到磁带上. 如果 flush 为 NULL, 内核简单地忽略用户应用程序的请求.

* int (*release) (struct inode *, struct file *);

> 在文件结构被释放时引用这个操作. 如同 open, release 可以为 NULL.

* int (*fsync) (struct file *, struct dentry *, int);

> 这个方法是 fsync 系统调用的后端, 用户调用来刷新任何挂着的数据. 如果这个指针是 NULL, 系统调用返回 -EINVAL.

* int (*aio_fsync)(struct kiocb *, int);

> 这是 fsync 方法的异步版本.

* int (*fasync) (int, struct file *, int);

> 这个操作用来通知设备它的 FASYNC 标志的改变. 如果驱动不支持异步通知这个成员可以是 NULL.

* int (*lock) (struct file *, int, struct file_lock *);

> lock 方法用来实现文件加锁. 加锁对常规文件是必不可少的特性, 但是设备驱动几乎从不实现它.

* ssize_t (*readv) (struct file *, const struct iovec *, unsigned long, loff_t *);
* ssize_t (*writev) (struct file *, const struct iovec *, unsigned long, loff_t *);

> 这些方法实现发散/汇聚读和写操作. 应用程序偶尔需要做一个包含多个内存区的单个读或写操作. 这些系统调用允许它们这样做而不必对数据进行额外拷贝. 如果这些函数指针为 NULL、read 和 write 方法被调用( 可能多于一次 ).

* ssize_t (*sendfile)(struct file *, loff_t *, size_t, read_actor_t, void *);

> 这个方法实现 sendfile 系统调用的读, 使用最少的拷贝从一个文件描述符搬移数据到另一个. 例如, 它被一个需要发送文件内容到一个网络连接的 web 服务器使用. 设备驱动常常使 sendfile 为 NULL.

* ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);

> sendpage 是 sendfile 的另一半. 它由内核调用来发送数据, 一次一页, 到对应的文件. 设备驱动实际上不实现 sendpage.

* unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned
long, unsigned long);

> 这个方法的目的是在进程的地址空间找一个合适的位置来映射在底层设备上的内存段中. 这个任务通常由内存管理代码进行. 这个方法存在为了使驱动能强制特殊设备可能有的任何的对齐请求. 大部分驱动可以置这个方法为 NULL.

* int (*check_flags)(int);

> 这个方法允许模块检查传递给 fnctl(F_SETFL...) 调用的标志.

* int (*dir_notify)(struct file *, unsigned long);

> 这个方法在应用程序使用 fcntl 来请求目录改变通知时调用. 只对文件系统有用. 驱动不需要实现 dir_notify.

scull 设备驱动只实现最重要的设备方法. 它的 file_operations 结构是如下初始化的:

```C
struct file_operations scull_fops = {
.owner = THIS_MODULE,
.llseek = scull_llseek,
.read = scull_read,
.write = scull_write,
.ioctl = scull_ioctl,
.open = scull_open,
.release = scull_release,
};
```

<b>文件结构</b>

