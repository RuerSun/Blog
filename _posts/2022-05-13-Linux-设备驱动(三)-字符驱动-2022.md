---
layout:     post
title:      "Linux 设备驱动(三) 字符驱动, 2022"
subtitle:   "欢迎使用"
date:       2022-05-13 12:31:20
author:     "Ruer"
header-img: "img/bg/hello_world.jpg"
catalog: true
tags:
    - Linux
---

## scull 的设计

贯串本章, 展示从一个真实设备驱动提取的代码片段: `scull`( Simple Character Utility for Loading Localities). scull 是一个字符驱动, 操作一块内存区域好像它是一个设备, 不依赖硬件. scull 只演示内核和字符驱动的接口和允许用户运行一些测试之外, 不做任何有用的事情. scull 源码实现下面的设备.  

* scull0 到 scull3

> 4 个设备, 每个由一个全局永久的内存区组成. 全局意味着如果设备被多次打开, 设备中含有的数据由所有打开它的文件描述符共享. 永久意味着如果设备关闭又重新打开, 数据不会丢失. 可以用惯常的命令来存取和测试, 例如 cp 和 cat, 以及 I/O 重定向.

* scullpipe0 到 scullpipe3

> 4 个 FIFO (先入先出) 设备, 行为象管道. 一个进程读的内容来自另一个进程所写的. 如果多个进程读同一个设备, 它们竞争数据. scullpipe 的内部将展示阻塞读写和非阻塞读写如何实现, 而不必采取中断. 尽管真实的驱动使用硬件中断来同步它们的设备, 阻塞和非阻塞操作的主题是重要的并且与中断处理是分开的.  

* scullsingle
* scullpriv
* sculluid
* scullwuid

> 这些设备与 scull0 相似, 但是在什么时候允许打开上有一些限制. 第一个( snullsingle) 只允许一次一个进程使用驱动, 而 scullpriv 对每个虚拟终端(或者 X 终端会话)是私有的, 因为每个控制台/终端上的进程有不同的内存区.
sculluid 和 scullwuid 可以多次打开, 但是一次只能是一个用户. 前者返回一个"设备忙"错误, 如果另一个用户锁着设备, 而后者实现阻塞打开.  

## 主次编号

字符设备通过文件系统中的名子来存取. 那些名子称为文件系统的特殊文件, 或者设备文件, 或者文件系统的简单结点, 位于 /dev 目录. 字符驱动的特殊文件由使用ls -l 的输出的第一列的"c"标识. 块设备也出现在 /dev 中, 但是它们由"b"标识.  

```Shell
crw-rw-rw- 1 root root 1, 3 Apr 11 2002 null
crw------- 1 root root 10, 1 Apr 11 2002 psaux
crw------- 1 root root 4, 1 Oct 28 03:04 tty1
crw-rw-rw- 1 root tty 4, 64 Apr 11 2002 ttys0
crw-rw---- 1 root uucp 4, 65 Apr 11 2002 ttyS1
crw--w---- 1 vcsa tty 7, 1 Apr 11 2002 vcs1
crw--w---- 1 vcsa tty 7,129 Apr 11 2002 vcsa1
crw-rw-rw- 1 root root 1, 5 Apr 11 2002 zero
```

发出 ls -l 命令, 会看到在设备文件项中有 2 个数(由一个逗号分隔)在最后修改日期前面, 这些数字是给特殊设备的主次设备编号. 它们的主编号是 1, 4, 7, 和 10, 而次编号是 1, 3, 5, 64, 65, 和 129.  

传统上, 主编号标识设备相连的驱动. 例如, /dev/null 和 /dev/zero 都由驱动 1 来管理, 而虚拟控制台和串口终端都由驱动 4 管理. 同样, vcs1 和 vcsa1 设备都由驱动 7 管理. 现代 Linux 内核允许多个驱动共享主编号, 但是大部分设备仍然按照一个主编号一个驱动的原则来组织.

次编号被内核用来决定引用哪个设备. 依据你的驱动是如何编写的, 可以从内核得到一个你的设备的直接指针, 或者可以自己使用次编号作为本地设备数组的索引. 不论哪个方法, 内核自己几乎不知道次编号的任何事情, 除了它们指向你的驱动实现的设备.  

<b>设备编号的内部表示</b>

在内核中, `dev_t` 类型(在 `<linux/types.h>`中定义)用来持有设备编号. 利用在 `<linux/kdev_t.h>` 中的一套宏定义, 获得一个 dev_t 的主或者次编号.  

```C
MAJOR(dev_t dev);
MINOR(dev_t dev);
```

相反, 如果有主次编号, 需要将其转换为一个 dev_t, 使用:

```C
MKDEV(int major, int minor);
```

<b>分配和释放设备编号</b>

在建立一个字符驱动时需要做的第一件事是获取一个或多个设备编号来使用. 函数是 `register_chrdev_region`, 在 `<linux/fs.h>` 中声明:

```C
int register_chrdev_region(dev_t first, unsigned int count, char *name);
```

这里, `first` 是要分配的起始设备编号, 次编号部分常常是 0. `count` 是请求的连续设备编号的总数. `name` 是应当连接到这个编号范围的设备的名子. 它会出现在 /proc/devices 和 sysfs 中. 如果分配成功进行, register_chrdev_region 的返回值是 0. 出错的情况下, 返回一个负的错误码, 不能存取请求的区域.

也可以让内核动态分配一个主编号.  

```C
int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name);
```

使用这个函数, `dev` 是在函数成功完成时持有的分配范围的第一个数. `fisetminor` 是请求的第一个要用的次编号, 常常是 0. `count` 和 `name` 参数如同给 request_chrdev_region 的一样.

在不再使用它们时应释放它, 设备编号的释放使用:

```C
void unregister_chrdev_region(dev_t first, unsigned int count);
```

对于新驱动, 强烈建议使用动态分配来获取主设备编号, 而不是随机选取一个当前空闲的编号. 换句话说, 驱动应当使用 alloc_chrdev_region, 不是 register_chrdev_region.  

## 一些重要数据结构

