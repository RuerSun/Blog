---
layout:     post
title:      "数据结构（一）树, 2020"
subtitle:   "介绍"
date:       2020-12-13 08:54:00
author:     "Ruer"
header-img: "img/bg/hello_world.jpg"
catalog: true
tags:
    - 软件基础
---

## 概述

树状图是一种数据结构，它是由n（n>=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。

它具有以下的特点：

* 每个结点有零个或多个子结点；
* 没有父结点的结点称为根结点；
* 每一个非根结点有且只有一个父结点；
* 除了根结点外，每个子结点可以分为多个不相交的子树；

树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合。

![1](/img/SoftwareBase/Tree/树的分类.png)

## 术语

* `节点深度`：对任意节点x，x节点的深度表示为根节点到x节点的路径长度。所以根节点深度为0，第二层节点深度为1，以此类推
* `节点高度`：对任意节点x，叶子节点到x节点的路径长度就是节点x的高度
* `树的深度`：一棵树中节点的最大深度就是树的深度，也称为高度
* `父节点`：若一个节点含有子节点，则这个节点称为其子节点的父节点
* `子节点`：一个节点含有的子树的根节点称为该节点的子节点
* `节点的层次`：从根节点开始，根节点为第一层，根的子节点为第二层，以此类推
* `兄弟节点`：拥有共同父节点的节点互称为兄弟节点
* `度`：节点的子树数目就是节点的度
* `叶子节点`：度为零的节点就是叶子节点
* `祖先`：对任意节点x，从根节点到节点x的所有节点都是x的祖先（节点x也是自己的祖先）
* `后代`：对任意节点x，从节点x到叶子节点的所有节点都是x的后代（节点x也是自己的后代）
* `森林`：m颗互不相交的树构成的集合就是森林

## 树的分类

#### 满二叉树

叶子节点都在同一层并且除叶子节点外的所有节点都有两个子节点。

#### 完全二叉树

若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。

#### 二叉搜索树（BinarySearchTree）

`二叉查找树`、`二叉排序树`、`BST`，这几个都是别名。对于树中某个节点X, 左子树中所有值都小于X, 右子树所有值都大于X; 不足: 但是当原序列有序时二叉搜索树为右斜树，同时二叉树退化成单链表，搜索效率降低为 O(n)。

时间复杂度:

* 索引: O(log(n))
* 搜索: O(log(n))
* 插入: O(log(n))
* 删除: O(log(n))

#### 平衡二叉树

它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，平衡二叉树必定是二叉搜索树。

#### AVL树

#### 红黑树

红黑树是一种自平衡”二叉查找树”。红黑树在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍。

如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。

#### B-树

B-tree 或者 B树，“Balance Tree”, 阶为M的树, 满足:

* 每个非叶子节点由 n 个关键字和 n+1 个指针构成
* 所有节点关键字是按递增次序排列，并遵循左小右大原则
* 根节点的子节点数在 2 ~ M 之间
* 其他节点的子节点数在 M/2 ~ M 之间
* 所有叶子节点在相同的高度
* 一个度为M的B-Tree，设其索引N个key，则其树高h的上限为 logd((N+1)/2)，检索一个key复杂度为 logdN

#### B+树

* 要存储的数据只在叶子节点中, 非叶子节点不存储数据, 只有关键字
* 相邻的叶子节点之间都有一个链指针，不需要遍历整棵树就可以得到所存储的全部数据// Mysql执行range-query扫库很方便

#### 霍夫曼树

带权路径最短的二叉树称为哈夫曼树或最优二叉树。

## 二叉树的遍历

#### 先序遍历

#### 中序遍历

#### 后序遍历

#### 层序遍历