---
layout:     post
title:      "常用排序算法, 2020"
subtitle:   "介绍"
date:       2020-12-18 08:54:00
author:     "Ruer"
header-img: "img/bg/hello_world.jpg"
catalog: true
tags:
    - 软件基础
---

<b>索引</b>

* 交换排序: 冒泡排序, 快速排序
* 插入排序: 简单插入排序, 希尔排序
* 选择排序: 简单选择排序, 堆排序
* 归并排序: 归并排序
* 基数排序:
* 桶排序:

选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，泡排序、插入排序、归并排序和基数排序是稳定的排序算法。

## 交换排序

#### 冒泡排序(Bubble Sort)

![1](/img/SoftwareBase/Sort/冒泡排序1.png)

最原始的交换类排序方式。遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就交换位置。时间复杂度平均情况`O(n^2)`，最坏也是`O(n^2)`，最好时间复杂度是`O(n)`，解释一下最好时间复杂度：改进的冒泡算法增加一个标志位（是否发生了swap）,如果这次循环完毕检查标志仍是false，说明这次已经是排好序的，直接return。

当数组是已经排好序的，这种冒泡的时间复杂度是`O(n)`。

```C++
i∈[0,N-1)       //循环N-1遍
  j∈[0,N-1-i)   //每遍循环要处理的无序部分
    swap(j,j+1) //两两排序（升序/降序）
```

![2](/img/SoftwareBase/Sort/冒泡排序2.png)

* 优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了，结束。
* 优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。

#### 快速排序(Quick Sort)

![3](/img/SoftwareBase/Sort/快速排序.png)

快速排序（QuickSort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序n个项目要 (nlog n)次比较。在最坏状况下则需要 n^2次比较。

1. 从数列中挑出一个元素，称为”基准”（pivot），
2. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
3. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。
4. 递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

举例：对5，3，8，6，4这个无序序列进行快速排序(小→大)，右指针找比基准数小的，左指针找比基准数大的，然后交换位置。

* 用数组第一个元素最为基准值(pivotKey)。
* 5，3，8，6，4 用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。
* 5，3，8，6，4 首先设置i，j两个指针分别指向左右两端，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i，j位置。
* 5，3，4，6，8 然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。
* 4，3，5，6，8 一次划分后达到了左边比5小，右边比5大的目的。
* 以5 为分界点, 左序列 4, 3 和 右序列 6, 8 递归的进行排序。

上面留下来了一个问题为什么一定要j指针先动呢？首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。

```C++
// 快速排序, 从小到大
public static void quickSort(int[] arr, int left, int right) {
    if(left >= right)
        return ;
    int pivotPos = partition(arr, left, right);
    quickSort(arr, left, pivotPos-1);
    quickSort(arr, pivotPos+1, right);
}

public static int partition(int[] arr, int left, int right) {
    int pivotKey = arr[left];
    int pivotPointer = left;

    while(left < right) {
        while(left < right && arr[right] >= pivotKey)
            right --;
        while(left < right && arr[left] <= pivotKey)
            left ++;
        swap(arr, left, right); //把大的交换到右边，把小的交换到左边。
    }
    swap(arr, pivotPointer, left); //最后把pivot交换到中间
    return left;
}
```

时间复杂度平均`O(n log n)`，最坏`O(n^2)`。因为快排的实现是递归调用的， 而且每次函数调用中只使用了常数的空间，因此空间复杂度等于递归深度`O(log n)`。

## 插入排序

#### 插入排序(Insertion Sort)

#### 希尔排序(Shell Sort)

## 选择排序

#### 选择排序(Selection Sort)

#### 堆排序(Heap Sort)

## 归并排序

#### 归并排序(Merge Sort)

## 基数排序

#### 基数排序(Radix Sort)

## 桶排序

#### 桶排序(Bucket Sort)

## 排序算法的比较

## 排序算法的稳定性