---
layout:     post
title:      "Linker Script 脚本浅析, 2023"
subtitle:   "欢迎使用"
date:       2023-04-06 10:03:20
author:     "Ruer"
header-img: "img/bg/hello_world.jpg"
catalog: true
tags:
    - Compile
---

## 概论

每一个链接过程都由链接脚本(linker script, 一般以 lds 作为文件的后缀名)控制. 链接脚本主要用于规定如何把输入文件内的 section 放入输出文件内, 并控制输出文件内各部分在程序地址空间内的布局. 但你也可以用连接命令做一些其他事情.

链接器有个默认的内置链接脚本, 可用 `ld --verbose` 查看. 连接选项 -r 和 -N 可以影响默认的链接脚本.

-T 选项用以指定自己的链接脚本, 它将代替默认的链接脚本。你也可以使用 `<隐式的连接脚本>` 以增加自定义的链接命令.

## 基础概念

链接器把一个或多个输入文件合成一个输出文件.

<b>输入文件:</b> 目标文件或链接脚本文件.  
<b>输出文件:</b> 目标文件或可执行文件.  

```TXT
目标文件(包括可执行文件)具有固定的格式, 在 UNIX 或 GNU/Linux 平台下, 一般为 ELF 格式.
若想了解更多, 可参考 UNIX/Linux 平台可执行文件格式分析.
```

有时把输入文件内的 section 称为输入 section(input section), 把输出文件内的 section 称为输出 section(output sectin).

目标文件的每个 section 至少包含两个信息: 名字和大小. 大部分 section 还包含与它相关联的一块数据, 称为 section contents(section 内容). 一个 section 可被标记为 “loadable(可加载的)” 或 “allocatable(可分配的)”.

<b>loadable section:</b> 在输出文件运行时, 相应的 section 内容将被载入进程地址空间中.  
<b>allocatable section:</b> 内容为空的 section 可被标记为“可分配的”. 在输出文件运行时, 在进程地址空间中空出大小同 section 指定大小的部分. 某些情况下, 这块内存必须被置零.

如果一个 section 不是“可加载的”或“可分配的”, 那么该 section 通常包含了调试信息. 可用 objdump -h 命令查看相关信息.

每个“可加载的”或“可分配的”输出 section 通常包含两个地址: VMA(virtual memory address 虚拟内存地址)和 LMA(load memory address 加载内存地址). 通常 VMA 和 LMA 是相同的.

```TXT
在目标文件中, loadable 或 allocatable 的输出 section 有两种地址: VMA(virtual Memory Address) 和 LMA(Load Memory Address). 
1. VMA 是执行输出文件时 section 所在的地址.
2. LMA 是加载输出文件时 section 所在的地址. 
一般而言 section 的 VMA == LMA. 但在嵌入式系统中, 经常存在加载地址和执行地址不同的情况: 比如将输出文件加载到开发板的 flash 中(由 LMA 指定), 而在运行时将位于 flash 中的输出文件复制到 SDRAM 中(由 VMA 指定).
```

可这样来理解 VMA 和 LMA, 假设:

(1) .data section 对应的 VMA 地址是 0x08050000, 该 section 内包含了 3 个 32 位全局变量, i、j 和 k, 分别为 1, 2, 3.  
(2) .text section 内包含由 `printf( "j=%d ", j );` 程序片段产生的代码.  

链接时指定 .data section 的 VMA 为 0x08050000, 产生的 printf 指令是将地址为 0x08050004 处的 4 字节内容作为一个整数打印出来。

如果 .data section 的 LMA 为 0x08050000，显然结果是 j=2  
如果 .data section 的 LMA 为 0x08050004，显然结果是 j=1  

还可这样理解 LMA:
.text section 内容的开始处包含如下两条指令(intel i386 指令是 10 字节，每行对应 5 字节):

```ASM
jmp 0x08048285
movl $0x1,%eax
```

如果 .text section 的 LMA 为 0x08048280, 那么在加载内存地址内 0x08048280 处为 “jmp 0x08048285” 指令, 0x08048285 处为 movl $0x1,%eax 指令. 假设某指令跳转到地址 0x08048280, 显然它的执行将导致 %eax 寄存器被赋值为 1.

如果 .text section 的 LMA 为 0x08048285, 那么在加载内存地址内 0x08048285 处为 “jmp 0x08048285” 指令, 0x0804828a 处为 movl $0x1,%eax 指令. 假设某指令跳转到地址 0x08048285, 显然它的执行又跳转到加载内存地址内 0x08048285处, 造成死循环.

<b>符号(symbol):</b> 每个目标文件都有符号表(SYMBOL TABLE), 包含已定义的符号(对应全局变量和 static 变量和定义的函数的名字)和未定义符号(未定义的函数的名字和引用但没定义的符号)信息.

<b>符号值:</b> 每个符号对应一个地址, 即符号值(这与 c 程序内变量的值不一样, 某种情况下可以把它看成变量的地址). 可用 nm 命令查看它们.

## 脚本格式

