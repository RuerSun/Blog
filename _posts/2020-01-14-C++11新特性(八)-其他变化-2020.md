---
layout:     post
title:      "C++11新特性(八)其他变化, 2020"
subtitle:   "简介"
date:       2020-01-14 16:02:00
author:     "Ruer"
header-img: "img/bg/hello_world.jpg"
catalog: true
tags:
    - C++
---

## 基于范围的 for 循环

```C++
vector<int> vec;
for (auto iter = vec.begin(); iter != vec.end(); iter++) { // before c++11
    cout << *iter << endl;
}
for (int i : vec) { // c++11 基于范围的 for 循环
    cout << "i" << endl;
}
```

## 委托构造函数

委托构造函数允许在同一个类中一个构造函数调用另外一个构造函数， 可以在变量初始化时简化操作， 通过代码来感受下委托
构造函数的妙处吧。

不使用委托构造函数：

```C++
struct A {
    A(){}
    A(int a) { a_ = a; }
    A(int a, int b) { // 好麻烦
        a_ = a;
        b_ = b;
    }
    A(int a, int b, int c) { // 好麻烦
        a_ = a;
        b_ = b;
        c_ = c;
    }
    int a_;
    int b_;
    int c_;
};
```

使用委托构造函数：

```C++
struct A {
    A(){}
    A(int a) { a_ = a; }
    A(int a, int b) : A(a) { b_ = b; }
    A(int a, int b, int c) : A(a, b) { c_ = c; }
    int a_;
    int b_;
    int c_;
};
```

## 继承构造函数

继承构造函数可以让派生类直接使用基类的构造函数， 如果有一个派生类， 我们希望派生类采用和基类一样的构造方式， 可以
直接使用基类的构造函数， 而不是再重新写一遍构造函数。

不使用继承构造函数：

```C++
struct Base {
    Base() {}
    Base(int a) { a_ = a; }
    Base(int a, int b) : Base(a) { b_ = b; }
    Base(int a, int b, int c) : Base(a, b) { c_ = c; }
    int a_;
    int b_;
    int c_;
};
struct Derived : Base {
    Derived() {}
    Derived(int a) : Base(a) {} // 好麻烦
    Derived(int a, int b) : Base(a, b) {} // 好麻烦
    Derived(int a, int b, int c) : Base(a, b, c) {} // 好麻烦
};
int main() {
    Derived a(1, 2, 3);
    return 0;
}
```

使用继承构造函数：

```C++
struct Base {
    Base() {}
    Base(int a) { a_ = a; }
    Base(int a, int b) : Base(a) { b_ = b; }
    Base(int a, int b, int c) : Base(a, b) { c_ = c; }
    int a_;
    int b_;
    int c_;
};
struct Derived : Base {
    using Base::Base;
};
int main() {
    Derived a(1, 2, 3);
    return 0;
}
```

只需要使用 using Base::Base 继承构造函数， 就免去了很多重写代码的麻烦。

## nullptr

nullptr 是 c++11 用来表示空指针新引入的常量值， 在 c++中如果表示空指针语义时建议使用 nullptr 而不要使用 NULL， 因为 NULL 本质上是个 int 型的 0， 其实不是个指针。 举例：

```C++
void func(void *ptr) {
    cout << "func ptr" << endl;
}
void func(int i) {
    cout << "func i" << endl;
}
int main() {
    func(NULL); // 编译失败， 会产生二义性
    func(nullptr); // 输出 func ptr
    return 0;
}
```

## final & override

c++11 关于继承新增了两个关键字， final 用于修饰一个类， 表示禁止该类进一步派生和虚函数的进一步重载， override 用于修饰派生类中的成员函数， 标明该函数重写了基类函数， 如果一个函数声明了 override 但父类却没有这个虚函数， 编译报错， 使用 override 关键字可以避免开发者在重写基类函数时无意产生的错误。

示例代码 1：

```C++
struct Base {
    virtual void func() {
        cout << "base" << endl;
    }
};
struct Derived : public Base{
    void func() override { // 确保 func 被重写
        cout << "derived" << endl;
    }
    void fu() override { // error， 基类没有 fu()， 不可以被重写
    }
};
```

示例代码 2：

```C++
struct Base final {
    virtual void func() {
        cout << "base" << endl;
    }
};
struct Derived : public Base{ // 编译失败， final 修饰的类不可以被继承
    void func() override {
        cout << "derived" << endl;
    }
};
```

## default

c++11 引入 default 特性， 多数时候用于声明构造函数为默认构造函数， 如果类中有了自定义的构造函数， 编译器就不会隐式
生成默认构造函数， 如下代码：

```C++
struct A {
    int a;
    A(int i) { a = i; }
};
int main() {
    A a; // 编译出错
    return 0;
}
```

上面代码编译出错， 因为没有匹配的构造函数， 因为编译器没有生成默认构造函数， 而通过 default， 程序员只需在函数声明后
加上“=default;”， 就可将该函数声明为 defaulted 函数， 编译器将为显式声明的 defaulted 函数自动生成函数体， 如下：

```C++
struct A {
    A() = default;
    int a;
    A(int i) { a = i; }
};
int main() {
    A a; //编译通过。
    return 0;
}
```

## delete

c++中， 如果开发人员没有定义特殊成员函数， 那么编译器在需要特殊成员函数时候会隐式自动生成一个默认的特殊成员函数，
例如拷贝构造函数或者拷贝赋值操作符， 如下代码：

```C++
struct A {
    A() = default;
    int a;
    A(int i) { a = i; }
};
int main() {
    A a1;
    A a2 = a1; // 正确， 调用编译器隐式生成的默认拷贝构造函数
    A a3;
    a3 = a1; // 正确， 调用编译器隐式生成的默认拷贝赋值操作符
}
```

而我们有时候想禁止对象的拷贝与赋值， 可以使用 delete 修饰， 如下：

```C++
struct A {
    A() = default;
    A(const A&) = delete;
    A& operator=(const A&) = delete;
    int a;
    A(int i) { a = i; }
};
int main() {
    A a1;
    A a2 = a1; // 错误， 拷贝构造函数被禁用
    A a3;
    a3 = a1; // 错误， 拷贝赋值操作符被禁用
}
```

delele 函数在 c++11 中很常用， std::unique_ptr 就是通过 delete 修饰来禁止对象的拷贝的。

## explicit

explicit 专用于修饰构造函数， 表示只能显式构造， 不可以被隐式转换， 根据代码看 explicit 的作用：

不用 explicit：

```C++
struct A {
    A(int value) { // 没有 explicit 关键字
        cout << "value" << endl;
    }
};
int main() {
    A a = 1; // 可以隐式转换
    return 0;
}
```

使用 explicit:

```C++
struct A {
    explicit A(int value) {
        cout << "value" << endl;
    }
};
int main() {
    A a = 1; // error， 不可以隐式转换
    A aa(2); // ok
    return 0;
}
```

## onst

因为要讲后面的 constexpr， 所以这里简单介绍下 const。

const 字面意思为只读， 可用于定义变量， 表示变量是只读的， 不可以更改， 如果更改， 编译期间就会报错。

主要用法如下：

1. 用于定义常量， const 的修饰的变量不可更改。

```C++
const int value = 5;
```

2. 指针也可以使用 const， 这里有个小技巧， 从右向左读， 即可知道 const 究竟修饰的是指针还是指针所指向的内容。

```C++
char *const ptr; // 指针本身是常量
const char* ptr; // 指针指向的变量为常量
```

3. 在函数参数中使用 const， 一般会传递类对象时会传递一个 const 的引用或者指针， 这样可以避免对象的拷贝， 也可以防止
对象被修改。

```C++
class A{};void func(const A& a);
```

4. const 修饰类的成员变量， 表示是成员常量， 不能被修改， 可以在初始化列表中被赋值。

```C++
class A {
    const int value = 5;
};
class B {
    const int value;
    B(int v) : value(v){}
};
```

5. 修饰类成员函数， 表示在该函数内不可以修改该类的成员变量。

```C++
class A{
    void func() const;
};
```

6. 修饰类对象， 类对象只能调用该对象的 const 成员函数。

```C++
class A {
    void func() const;
};
const A a;
a.func();
```

## constexpr