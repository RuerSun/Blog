---
layout:     post
title:      "shell 脚本介绍, 2021"
subtitle:   "介绍"
date:       2021-05-19 17:22:00
author:     "Ruer"
header-img: "img/bg/hello_world.jpg"
catalog: true
tags:
    - shell
---

## 功能简介

最简单的解释是，shell 脚本是一个包含一系列命令的文件。shell 读取这个文件，然后执行这些命令，就好像这些命令是直接输入到命令行中一样。

shell 很独特，因为它既是一个强大的命令行接口，也是一个脚本语言解释器。我们将会看到，大多数能够在命令行中完成的工作都可以在脚本中完成，反之亦然。

```
sky@ubuntu:~/Work$ echo $PATH
/home/sky/bin:/home/sky/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
```

上述命令可以将环境变量中的路径打印出来，如果将 shell 文件放在目录下，可以直接输文件名执行，否则要跟上 shell 文件的路径。

~/bin 目录是一个存放个人使用脚本的理想位置。如果我们编写了一个系统上所有用户都可以使用的脚本，则该脚本的传统位置是 /usr/local/bin，系统管理员使用的脚本通常放置在 /usr/local/sbin，在大多数情况下，本地支持的软件，无论是脚本或者是编译好的程序，应该放置在 /usr/local 目录下，而不是 /bin 或是 /usr/bin 目录下。这些目录都是由 Linux 文件系统层次结构标准指定的，只能包含发行商所提供和维护的文件。

## 书写格式

基本的书写格式如下：

```
#!/bin/bash

# This is our first script.

echo 'Hello \
      World!'
```

第一句的 `#!/bin/bash` 是指此脚本使用 /bin/bash 来解释执行，`#!` 是特殊的表示符，其后面根的是此解释此脚本的 shell 的路径，我们可以用各种各样的解释器来写对应的脚本。比如说 /bin/csh 脚本，/bin/perl 脚本，/bin/awk 脚本，/bin/sed 脚本，甚至 /bin/echo 等等。

第二句表示注释同一行中，`#` 之后的内容。

第三句是脚本执行的具体内容，向终端数据 Hello World 字符串。支持通过 / 符号进行行连接。

## 基本语法

#### 变量和常量

变量的命名规则如下所示。

> 1. 变量名称应由字母、数字和下划线组成。
> 2. 变量名称的第一个字符必须是字母或者下划线。
> 3. 变量名称中不允许空格和标点。

```
#!/bin/bash

# Program to output a system information page

TITLE="System Information Report For $HOSTNAME"

echo '<HTML>
          <HEAD>
              <TITLE>$TITLE</TITLE>
          </HEAD>
          <BODY>
              <H1>$TITLE</H1>
          </BODY>
</HTML>'
```

普遍约定，使用大写字母表示常量，使用小写字母表示变量。

```
a=z                     # 将字符串 “z” 赋值给变量 a
b="a string"            # 嵌入的空格必须用引号括起来
c="a string and $b"     # 可以被扩展到赋值语句中的其他扩展，比如变量
d=$(ls-l foo.txt)       # 命令的结果
e=$((5*7))              # 算数扩展
f="\t\ta string\n"      # 转义序列，比如制表符和换行符
```

可以在一行中给多个变量赋值。

```
a=5 b="a string"
```

在扩展期间，变量名称可以用花括号 “{}” 括起来。当变量名因为周围的上下文而变得不明确时，这就会很有帮助了。在这里，我们使用变量将一个文件的名字由 myfile 改为 myfile1：

```
sky@ubuntu:~/Work$ filename="myfile"
sky@ubuntu:~/Work$ touch $filename
sky@ubuntu:~/Work$ mv $filename $filename1
mv: missing destination file operand after 'myfile'
Try 'mv --help' for more information.
```

因为 shell 将 mv 命令的第二个参数当成了一个新的变量，所以这样做没有成功。该问题可以用以下方法解决。

```
sky@ubuntu:~/Work$ mv $filename ${filename}1
```

局部变量可以通过在变量名前面添加单词 local 来定义，这样，就创建并同时定义了一个 shell 函数中的局部变量。一且出了这个 shell 函数，这个局部变量将不再存在。

```
#!/bin/bash

# local-vars: script to demonsrtate local variables

foo=0 # global variable foo

func_1() {
  local foo # variable foo local to func_1

  foo=1
  echo "func_1: foo = $foo"
}

func_2() {
  local foo # variable foo local to func_2

  foo=2
  echo "func_2: foo = $foo"
}

echo "global: foo = $foo"
func_1
echo "global: foo = $foo"
func_2
echo "global: foo = $foo"
```

#### IF语句

基本格式如下：

```
if commands; then
      commands
[elif commands; then
      commands...]
[else
      commands]
fi
```

其中 command 支持如下几种表达式。

1. 文件表达式。

| 表达式 | 成为 true 的条件 |
| :----: | :-------------: |
| file1 -ef file2 | file1 和 file2 拥有相同的信息节点编号（这两个文件通过硬链接指向同一个文件） |
| file1 -nt file2 | filel 比 file2 新 |
| file1 -ot file2 | file1 比 file2 旧 |
| -b file         | file 存在井且是一个块（设备）文件 |
| -c file         | file 存在井且是一个字符（设备）文件 |
| -d file         | file 存在并且是一个目录 |
| -e file         | file 存在 |
| -f file         | file 存在并且是一个通文件 |
| -g file         | file 存在井且设置了组 ID |
| -G file         | file 存在井且属于有效组 ID |
| -k file         | file 存在并且有 “粘滞位（sticky bit）" 属性 |
| -L file         | file 存在并且是一个符号链接 |
| -O file         | file 存在并且属于有效用户 ID |
| -p file         | file 存在并且是一个命名管道 |
| -r file         | file 存在并且可读（有效用户有可读权限） |
| -s file         | file 存在并且其长度大于0 |
| -S file         | file 存在并且是一个网络套接字 |
| -t fd           | fd 是一个定向到终/从终端定向的文件描述符，可以用来确定标准输入/输出/错误是否被重定向 |
| -u file         | file 存在并且设置了 setuid 位 |
| -w file         | file 存在并且可写（有效用户拥有可写权限） |
| -x file         | file 存在并且可执行（有效用户拥有执行/搜索权限） |

例子：

```
#!/bin/bash

# test-file: Evaluate the status of a file.

FILE=~/.bashrc

if [ -e "$FILE" ]; then
    if [ -f "$FILE" ]; then
        echo "$FILE is a regular file."
    fi
    if [ -d "$FILE" ]; then
        echo "$FILE is a directory."
    fi
    if [ -r "$FILE" ]; then
        echo "$FILE is readable."
    fi
    if [ -w "$FILE" ]; then
        echo "$FILE is writable."
    fi
    if [ -x "$FILE" ]; then
        echo "$FILE is executable/searchable"
    fi
else
    echo "$FILE does not exist"
    exit 1
fi

exit
```

2. 字符串表达式。

| 表达式 | 成为 true 的条件 |
| :----: | :-------------: |
| string | string 不为空 |
| -n string | string 的长度大于0 |
| -z string | string 的长度等于0 |
| string1=string2 <br> string1==string2 | string1 和 string2 相等，单等号和双等号都可以使用，但是双等号使用的更多 |
| string1!=string2 | string1 和 string2 不相等 |
| string1>string2 | 在排序时，string1 在 string2 之后 |
| string1<string2 | 在排序时，string1 在 string2 之前 |

例子：

```
#!/bin/bash

# test-string: evaluate the value of a string.

ANSWER=maybe

if [ -z "$ANSWER" ]; then
    echo "There is no answer." >&2
    exit 1
fi

if [ "$ANSWER" = "yes" ]; then
    echo "The answer is YES."
elif [ "$ANSWER" = "no" ]; then
    echo "The answer is NO."
elif [ "$ANSWER" = "maybe" ]; then
    echo "The answer is MAYBE."
else
    echo "The answer isThe answer is UNKNOWN."
fi
```

3. 正数表达式。

| 表达式 | 成为 true 的条件 |
| :----: | :-------------: |
| integer1 -eq integer2 | integer1 和 integer2 相等 |
| integer1 -ne integer2 | integer1 和 integer2 不相等 |
| integer1 -le integer2 | integer1 小于等于 integer2 |
| integer1 -lt integer2 | integer1 小于 integer2 |
| integer1 -ge integer2 | integer1 大于等于 integer2 |
| integer1 -gt integer2 | integer1 大于 integer2 |

例子：

```
#!/bin/bash

# test-integer: evaluate the value of an integer.

INT=-5

if [ -z "$INT" ]; then
    echo "INT is empty." >&2
    exit 1
fi

if [ $INT -eq 0 ]; then
    echo "INT is zero."
else
    if [ $INT -lt 0 ]; then
        echo "INT is negative."
    else
        echo "INT is positive."
    fi
    if [ $((INT % 2)) -eq 0]; then
        echo "INT is even."
    else
        echo "INT is odd."
    fi
fi
```

4. 组合表达式

| Operation | test | [[]]and(()) |
| :-------: | :--: | :---------: |
| AND | -a  | &&    |
| OR  | -o  | \|\|  |
| NOT | !   | !     |

例子：

```
#!/bin/bash

# test-integer: determine if an integer is outside a
# specified range of values.

MIN_VAL=1
MAX_VAL=100

if [[ "$INT" =~ ^-?[0-9]+$]]; then
    if [[!(INT -ge MIN_VAL && INT -le MAX_VAL)]]; then
        echo "$INT is outside $MIN_VAL to $MAX_VAL."
    else
        echo "$INT is in range."
    fi
else
    echo "INT is not an integer." >&2
    exit 1
fi
```

#### FOR 语句

## 扩展