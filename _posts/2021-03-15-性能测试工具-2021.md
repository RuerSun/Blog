---
layout:     post
title:      "性能测试工具"
subtitle:   "分析工具"
date:       2021-03-15 12:50:00
author:     "Ruer"
header-img: "img/bg/hello_world.jpg"
catalog: true
tags:
    - Debug
---

## Oprofile

<b>简介</b>

其原理是：现在的很多 CPU都提供一个所谓性能计数器的东西（performance counter），大致的原理就是程序可以注册告诉CPU对什么event感兴趣（比如CPU_CYCLE，CPU经历了一次时钟周期），然后CPU在执 行了相应的操作后，就会在性能计数器上加1，这样程序就可以取出。所以，使用OProfile来定位CPU使用率的问题，就变成了让oprofile收集 程序运行过程中哪个可执行程序（或是so）中的哪个function，消耗的CPU CYCLE最多。

也就是说我们可以通过收集数据知道哪个程序的哪个函数消耗的cpu时间占比。这种测试方法结果更符合实际情况。

<b>结果分析</b>

Oprofile的数据有两种查看方式：

1. 使用opreport查看。
2. 也可以使用工具，生成图片查看。

<b>点评</b>

优点：oprofile是对整个系统的性能进行分析，采用的是硬件计数器，效率高，负载低，且结果准确。

缺点：需要更换内核，需要root权限。

## gprof

<b>简介</b>

产生程序运行时候的函数调用关系，包括调用次数，可以帮助程序员分析程序的运行流程。

有了函数的调用关系，这会让开发人员大大提高工作效率，不用费心地去一点点找出程序的运行流程，这对小程序来说可能效果不是很明显，但对于有几万，几十万代码量的工程来说，效率是毋庸置疑的！而且这个功能对于维护旧代码或者是分析Open Source来说那是相当诱人的，有了调用图，对程序的运行框架也就有了一个大体了解，知道了程序的"骨架"，分析它也就不会再那么茫然，尤其是对自己不熟悉的代码和Open Source。

<b>点评</b>

优点：oprofile是对整个系统的性能进行分析，采用的是硬件计数器，效率高，负载低，且结果准确。

缺点：需要更换内核，需要root权限。

优点：

* GNU工具，人手一个。
* 混合方法采集信息。

缺点：
1. 需要编译选项支持：
    * i. 使用gcc/cc编译和链接时需要加入-pg选项
    * ii. 使用ld链接时需要用/lib/gcrt0.o代替crt0.o作为第一个input文件
    * iii. 如果要调试libc库需要使用-lc_p代替-lc参数
2. 调试多线程程序只能统计主线程的信息（所以不能用于kingbase）。

## perf

<b>概述</b>

perf是Linux下的一款性能分析工具，能够进行函数级与指令级的热点查找。它由一个叫“Performance counters“的内核子系统实现，基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析，可用于性能瓶颈的查找与热点代码的定位。

<b>基本原理</b>

硬件的话采用PMC（performance monitoring unit）CPU的部件，在特定的条件下探测的性能事件是否发生以及发生的次数。软件性能测试，内置于kernel，分布在各个功能模块中，统计和操作系统相关性能事件。

性能调优工具如 perf，Oprofile 等的基本原理都是对被监测对象进行采样，最简单的情形是根据 tick 中断进行采样，即在 tick 中断内触发采样点，在采样点里判断程序当时的上下文。假如一个程序 90% 的时间都花费在函数 foo() 上，那么 90% 的采样点都应该落在函数 foo() 的上下文中。运气不可捉摸，但我想只要采样频率足够高，采样时间足够长，那么以上推论就比较可靠。因此，通过 tick 触发采样，我们便可以了解程序中哪些地方最耗时间，从而重点分析。