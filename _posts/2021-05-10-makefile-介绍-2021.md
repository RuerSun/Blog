---
layout:     post
title:      "makefile 介绍, 2021"
subtitle:   "概要介绍"
date:       2021-05-10 22:25:00
author:     "Ruer"
header-img: "img/bg/hello_world.jpg"
catalog: true
tags:
    - makefile
---

## makefile 的规则

在讲述这个 makefle 之前，还是让我们先来粗略地看一看 makefle 的规则。

```
target ... : prerequisites ...
  command
  ...
  ...
```

`target` 可以是一个 object fle（目标文件），也可以是一个执行文件，还可以是一个标签（ label）。对于
标签这种特性，在后续的“伪目标”章节中会有叙述。  
`prerequisites` 生成该 target 所依赖的文件和/或 target  
`command` 该 target 要执行的命令（任意的 shell 命令）  

这是一个文件的依赖关系，也就是说， target 这一个或多个的目标文件依赖于 prerequisites 中的文
件，其生成规则定义在 command 中。说白一点就是说:

> prerequisites 中如果有一个以上的文件比 target 文件要新的话， command 所定义的命令就会被执
行。

这就是 makefle 的规则，也就是 makefle 中最核心的内容。

## 一个示例

正如前面所说，如果一个工程有 3 个头文件和 8 个 c 文件，为了完成前面所述的那三个规则，我们
的 makefle 应该是下面的这个样子的。

```
edit : main.o kbd.o command.o display.o \
    insert.o search.o files.o utils.o
  cc -o edit main.o kbd.o command.o display.o \
    insert.o search.o files.o utils.o
main.o : main.c defs.h
  cc -c main.c
kbd.o : kbd.c defs.h command.h
  cc -c kbd.c
command.o : command.c defs.h command.h
  cc -c command.c
display.o : display.c defs.h buffer.h
  cc -c display.c
insert.o : insert.c defs.h buffer.h
  cc -c insert.c
search.o : search.c defs.h buffer.h
  cc -c search.c
files.o : files.c defs.h buffer.h command.h
  cc -c files.c
utils.o : utils.c defs.h
  cc -c utils.c
clean :
  rm edit main.o kbd.o command.o display.o \
    insert.o search.o files.o utils.o
```

反斜杠（ \ ）是换行符的意思。这样比较便于 makefle 的阅读。我们可以把这个内容保存在名字为
“ makefle”或“ Makefle”的文件中，然后在该目录下直接输入命令 make 就可以生成执行文件 edit。如
果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下 make clean 就可以了。

在这个 makefle 中，目标文件（ target）包含：执行文件 edit 和中间目标文件（ *.o ），依赖文件
（ prerequisites）就是冒号后面的那些 .c 文件和 .h 文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质就是说明了目标文件是由哪些文件生成的，换言
之，目标文件是哪些文件更新的。

在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个 `Tab
键作为开头`。记住， make 并不管命令是怎么工作的，他只管执行所定义的命令。 make 会比较 targets 文
件和 prerequisites 文件的修改日期，如果 prerequisites 文件的日期要比 targets 文件的日期要新，或者
target 不存在的话，那么， make 就会执行后续定义的命令。

这里要说明一点的是， clean 不是一个文件，它只不过是一个动作名字，有点像 c 语言中的 label 一
样，其冒号后什么也没有，那么， make 就不会自动去找它的依赖性，也就不会自动执行其后所定义的命
令。要执行其后的命令，就要在 make 命令后明显得指出这个 label 的名字。这样的方法非常有用，我们
可以在一个 makefle 中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。

## make 是如何工作的

在默认的方式下，也就是我们只输入 make 命令。那么，

> 1. make 会在当前目录下找名字叫“ Makefle”或“ makefle”的文件。
> 2. 如果找到，它会找文件中的第一个目标文件（ target），在上面的例子中，他会找到“ edit”这个文
件，并把这个文件作为最终的目标文件。
> 3. 如果 edit 文件不存在，或是 edit 所依赖的后面的 .o 文件的文件修改时间要比 edit 这个文件新，
那么，他就会执行后面所定义的命令来生成 edit 这个文件。
> 4. 如果 edit 所依赖的 .o 文件也不存在，那么 make 会在当前文件中找目标为 .o 文件的依赖性，如
果找到则再根据那一个规则生成 .o 文件。（这有点像一个堆栈的过程）

这就是整个 make 的依赖性， make 会一层又一层地去找文件的依赖关系，直到最终编译出第一个目
标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么 make 就会直接退出，并
报错，而对于所定义的命令的错误，或是编译不成功， make 根本不理。 make 只管文件的依赖性，即，如
果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。

通过上述分析，我们知道，像 clean 这种，没有被第一个目标文件直接或间接关联，那么它后面所定
义的命令将不会被自动执行，不过，我们可以显示要 make 执行。即命令——make clean ，以此来清除
所有的目标文件，以便重编译。

于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如 file.c ，那
么根据我们的依赖性，我们的目标 file.o 会被重编译（也就是在这个依性关系后面所定义的命令），于
是 file.o 的文件也是最新的啦，于是 file.o 的文件修改时间要比 edit 要新，所以 edit 也会被重新
链接了（详见 edit 目标文件后定义的命令）。

而如果我们改变了 command.h ，那么， kdb.o 、 command.o 和 files.o 都会被重编译，并且， edit
会被重链接。

## makefile 中使用变量

## 让 make 自动推导

## 另类风格的 makefiles

## 清空目标文件的规则

## makefile 里有什么

## makefile 的文件名

## 引用其它的 makefile

## 环境变量 MAKEFILES

## make 的工作方式